<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù†Ù‚Ø´Ù‡ Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ Ø§ÛŒØ±Ø§Ù† - Extrude</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            overflow: hidden;
        }
        #container { width: 100vw; height: 100vh; }
        #info {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 10, 20, 0.95); backdrop-filter: blur(15px);
            padding: 20px 25px; border-radius: 12px;
            border: 2px solid rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            color: #00ffff; z-index: 100; min-width: 250px;
        }
        #province-name {
            font-size: 24px; font-weight: bold; margin-bottom: 8px;
            text-shadow: 0 0 15px currentColor;
        }
        #province-info { font-size: 14px; color: rgba(255, 255, 255, 0.8); }
        .controls {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%); display: flex; gap: 12px; z-index: 100;
        }
        .btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.1));
            border: 2px solid rgba(0, 255, 255, 0.5); color: #00ffff;
            padding: 10px 20px; border-radius: 8px; cursor: pointer;
            font-size: 14px; font-weight: 600; transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 200, 255, 0.2));
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <div id="province-name">Ù†Ù‚Ø´Ù‡ Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ Ø§ÛŒØ±Ø§Ù†</div>
        <div id="province-info">Ù…ÙˆØ³ Ø±Ø§ Ø±ÙˆÛŒ Ø§Ø³ØªØ§Ù†â€ŒÙ‡Ø§ Ø­Ø±Ú©Øª Ø¯Ù‡ÛŒØ¯</div>
    </div>
    <div class="controls">
        <button class="btn" onclick="toggleRotation()">â¸ï¸ ØªÙˆÙ‚Ù Ú†Ø±Ø®Ø´</button>
        <button class="btn" onclick="resetView()">ğŸ”„ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ</button>
        <button class="btn" onclick="toggleWater()">ğŸ’§ Ù¾Ù†Ù‡Ø§Ù†/Ù†Ù…Ø§ÛŒØ´ Ø¯Ø±ÛŒØ§Ù‡Ø§</button>
        <button class="btn" onclick="showOnlyWater()">ğŸŒŠ ÙÙ‚Ø· Ø¯Ø±ÛŒØ§Ù‡Ø§</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let provinces = [];
        let waterBodies = [];
        let hoveredProvince = null;
        let autoRotate = true;
        let waterVisible = true;
        let provincesVisible = true;

        // Neon colors for hover effect (like the image)
        const provinceColors = {
            'azerbaijan-east': 0x00d4ff, 'azerbaijan-west': 0x00bfff, 'ardabil': 0x00e5ff,
            'gilan': 0x00c8ff, 'mazandaran': 0x00d9ff, 'golestan': 0x00ccff,
            'zanjan': 0x00b8ff, 'qazvin': 0x00d0ff, 'kurdistan': 0x00bbff,
            'kermanshah': 0x00c4ff, 'ilam': 0x00b0ff, 'lorestan': 0x00dcff,
            'khuzestan': 0x00a8ff, 'tehran': 0xffdd00, 'alborz': 0xaaff00,
            'qom': 0xffd700, 'markazi': 0xffcc00, 'semnan': 0x88ff00,
            'hamadan': 0xffc800, 'isfahan': 0xffb800,
            'chahar-mahaal-bakhtiari': 0xffa500, 'kohgiluyeh-boyer-ahmad': 0xff9500,
            'khorasan-north': 0xff6b9d, 'khorasan-razavi': 0xff5588,
            'khorasan-south': 0xff4477, 'sistan-baluchestan': 0xff3366,
            'kerman': 0xff5577, 'yazd': 0xff7788, 'fars': 0xff8844,
            'bushehr': 0xff9955, 'hormozgan': 0xff6655
        };

        const provinceNames = {
            'azerbaijan-east': 'Ø¢Ø°Ø±Ø¨Ø§ÛŒØ¬Ø§Ù† Ø´Ø±Ù‚ÛŒ', 'azerbaijan-west': 'Ø¢Ø°Ø±Ø¨Ø§ÛŒØ¬Ø§Ù† ØºØ±Ø¨ÛŒ',
            'ardabil': 'Ø§Ø±Ø¯Ø¨ÛŒÙ„', 'gilan': 'Ú¯ÛŒÙ„Ø§Ù†', 'mazandaran': 'Ù…Ø§Ø²Ù†Ø¯Ø±Ø§Ù†',
            'golestan': 'Ú¯Ù„Ø³ØªØ§Ù†', 'zanjan': 'Ø²Ù†Ø¬Ø§Ù†', 'qazvin': 'Ù‚Ø²ÙˆÛŒÙ†',
            'kurdistan': 'Ú©Ø±Ø¯Ø³ØªØ§Ù†', 'kermanshah': 'Ú©Ø±Ù…Ø§Ù†Ø´Ø§Ù‡', 'ilam': 'Ø§ÛŒÙ„Ø§Ù…',
            'lorestan': 'Ù„Ø±Ø³ØªØ§Ù†', 'khuzestan': 'Ø®ÙˆØ²Ø³ØªØ§Ù†', 'tehran': 'ØªÙ‡Ø±Ø§Ù†',
            'alborz': 'Ø§Ù„Ø¨Ø±Ø²', 'qom': 'Ù‚Ù…', 'markazi': 'Ù…Ø±Ú©Ø²ÛŒ', 'semnan': 'Ø³Ù…Ù†Ø§Ù†',
            'hamadan': 'Ù‡Ù…Ø¯Ø§Ù†', 'isfahan': 'Ø§ØµÙÙ‡Ø§Ù†',
            'chahar-mahaal-bakhtiari': 'Ú†Ù‡Ø§Ø±Ù…Ø­Ø§Ù„ Ùˆ Ø¨Ø®ØªÛŒØ§Ø±ÛŒ',
            'kohgiluyeh-boyer-ahmad': 'Ú©Ù‡Ú¯ÛŒÙ„ÙˆÛŒÙ‡ Ùˆ Ø¨ÙˆÛŒØ±Ø§Ø­Ù…Ø¯',
            'khorasan-north': 'Ø®Ø±Ø§Ø³Ø§Ù† Ø´Ù…Ø§Ù„ÛŒ', 'khorasan-razavi': 'Ø®Ø±Ø§Ø³Ø§Ù† Ø±Ø¶ÙˆÛŒ',
            'khorasan-south': 'Ø®Ø±Ø§Ø³Ø§Ù† Ø¬Ù†ÙˆØ¨ÛŒ', 'sistan-baluchestan': 'Ø³ÛŒØ³ØªØ§Ù† Ùˆ Ø¨Ù„ÙˆÚ†Ø³ØªØ§Ù†',
            'kerman': 'Ú©Ø±Ù…Ø§Ù†', 'yazd': 'ÛŒØ²Ø¯', 'fars': 'ÙØ§Ø±Ø³',
            'bushehr': 'Ø¨ÙˆØ´Ù‡Ø±', 'hormozgan': 'Ù‡Ø±Ù…Ø²Ú¯Ø§Ù†'
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e1a);
            scene.fog = new THREE.FogExp2(0x0a0e1a, 0.0003);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 500, 800);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 300;
            controls.maxDistance = 1500;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            setupLights();
            loadAndCreateProvinces();
            setupInteraction();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 400, 200);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0x00ffff, 0.8, 800);
            pointLight1.position.set(0, 200, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 800);
            pointLight2.position.set(-300, 150, 300);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xffff00, 0.5, 800);
            pointLight3.position.set(300, 150, -300);
            scene.add(pointLight3);
        }

        function loadAndCreateProvinces() {
            fetch('iranmap.html')
                .then(response => response.text())
                .then(html => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Load provinces
                    const pathElements = doc.querySelectorAll('.province path');
                    pathElements.forEach(pathEl => {
                        const className = pathEl.getAttribute('class');
                        const pathData = pathEl.getAttribute('d');
                        
                        if (provinceColors[className] && pathData) {
                            createProvinceFromPath(className, pathData, provinceColors[className]);
                        }
                    });

                    // Load Caspian Sea from HTML
                    const caspianPath = doc.querySelector('.sea path.caspian');
                    if (caspianPath) {
                        const pathData = caspianPath.getAttribute('d');
                        if (pathData) {
                            createSeaFromPath('caspian', pathData);
                        }
                    }

                    // Use custom clean path for Persian Gulf and Oman Sea (south waters)
                    const southWatersPath = "M60.86 0C60.37 1.64 59.26 3.41 60.39 5.06C62.69 9.26 62.45 14.06 61.89 18.66C54.57 24.53 44.96 27.55 35.62 26.02C31.66 25.23 28.43 22.61 24.91 20.81C26.33 25.8 29.69 29.8 32.29 34.19C34.51 37.47 31.56 41.12 29.45 43.61C25.61 47.79 19.49 45.02 14.64 44.99C11.52 44.07 9.53001 46.86 7.48001 48.63C5.19001 50.81 2.63 52.66 0 54.39C1.59 54.8 3.19 55.23 4.78 55.66C4.64 56.54 4.51001 57.42 4.37001 58.32C7.86001 57.85 12.38 55.97 15.06 59.23C19.48 64.31 18.53 71.51 20.2 77.62C20.93 81.12 23.64 83.63 25.98 86.14C27.08 89.03 28.55 91.75 30.12 94.41C31.89 97.35 31.49 100.94 32.52 104.13C33.47 106.03 35.12 107.47 36.51 109.06C36.78 113.21 36.15 117.93 39.01 121.37C40.31 123.38 42.84 125.04 42.42 127.74C42.57 129.69 42.07 131.81 42.86 133.67C45.61 136.32 49.14 137.98 52.2 140.24C51.26 140.5 49.36 141.02 48.42 141.28C51.81 144.64 55.51 148.33 55.08 153.54C53.85 154.22 52.61 154.92 51.38 155.63C53.39 155.52 55.97 154.04 57.57 155.86C57.63 157.47 57.61 159.1 57.47 160.72C57.88 160.74 58.71 160.78 59.13 160.8C60.53 162.72 61.41 165.67 64.09 166.14C67.47 166.77 70.96 166.36 74.34 167.04C76.18 168.65 76.57 171.24 77.48 173.41C74.195 173.156 70.9003 172.93 67.6149 172.705L67.39 172.69C69.45 173.68 71.7 174.45 73.46 175.97C75.72 178.21 75.65 181.62 76.22 184.54C78.44 186.24 80.37 188.25 82.16 190.4C82.77 189.08 83.39 187.74 84.02 186.45C85.48 186.8 86.96 187.16 88.43 187.51C90.22 191.91 91.74 196.6 94.87 200.27C98.52 204.28 104.09 205.22 108.74 207.55C112.69 210.17 114.74 214.73 116.32 219.03C114.481 218.697 112.66 218.348 110.832 217.997L110.38 217.91C110.83 221.61 110.54 225.71 112.66 228.95C115.5 232.02 121.52 232.68 121.67 237.72C122.87 244.99 118.64 251.5 115.02 257.4C113.47 253.88 112.25 250.23 110.44 246.84C109.85 249.33 109.62 251.88 109.58 254.44C111.61 255.84 113.62 257.28 115.6 258.77C115.61 261.02 115.38 263.32 115.87 265.55C116.89 268.59 119.1 271.01 120.96 273.57C119.54 274.07 118.14 274.6 116.73 275.12C119.93 277.08 122.38 279.93 124.28 283.14C126.61 287.28 132.62 287.79 134.14 292.55C136.58 299.05 136.66 306.12 136.93 312.98C137.93 312.76 138.94 312.56 139.95 312.37C141.54 314.95 142.74 317.74 143.72 320.61C146.81 323.5 147.22 327.81 147.9 331.75C148.52 331.7 149.77 331.6 150.39 331.55C150.98 328.46 151.56 325.18 150.15 322.23C146.21 312.14 145.58 301.1 147.16 290.45C148 286.44 146 282.69 145.7 278.77C146.11 276.75 147.81 275.37 148.94 273.76C150.44 275.5 152.07 277.14 153.58 278.89C155.5 273.4 157.46 267.93 158.83 262.28C160.12 255.98 167 254.07 171.69 250.89C174.41 248.79 177.59 251.03 180.37 251.82L180.37 251.821C181.34 255.111 182.31 258.4 183.11 261.75C186.68 261.27 190.04 262.43 192.78 264.72C192.64 269.25 193.23 273.99 191.54 278.32C190.43 281.33 188.25 283.86 187.34 286.95C188.01 291.17 189.9 295.27 189.04 299.65C190.58 300.08 192.11 300.49 193.66 300.93C192.87 306.21 193.28 311.54 193.56 316.84C193.87 320.56 190.94 323.33 188.93 326.1C185.73 329.93 184.71 334.94 183.41 339.63C184.67 340.66 185.92 341.7 187.18 342.76C184.23 344.85 181.16 346.93 178.96 349.86C177.01 352.36 176.21 355.49 175.22 358.45C178.07 357.6 181.09 355.98 184.12 356.95C186.94 358.3 189.01 360.77 191.34 362.8C194.47 360.64 197.87 358.13 201.91 359.18C202.13 364.77 200.21 371.07 203.22 376.16C206.8 378.27 211.32 377.89 215.36 378.03C226.21 378.05 237.78 373.65 243.63 364.04C249.66 367.97 257.27 369.21 264.23 367.35C267.21 366.14 269.7 368.63 272.16 369.9C272.37 368.95 272.79 367.04 273 366.08C276.14 367.03 278.71 369.11 281.6 370.59C284.88 370.71 288.1 369.71 291.39 369.95C293.42 370.36 295.18 371.55 296.99 372.53C303.04 372.71 309.4 373.55 315.17 371.23C319.08 369.7 323.03 368.31 327.1 367.27C324.5 364.65 322.23 361.7 320.73 358.32C325.11 357.49 328.43 360.31 331.29 363.17C334.29 361.95 337.7 361.42 340.26 359.34C342.51 356.49 340.7 352.65 340.44 349.45C343.81 350.42 347.19 351.3 350.6 352.1C349.1 350.63 347.64 349.12 346.15 347.65C348.35 346.19 351.02 344.82 351.92 342.13C352.84 339.1 352.52 335.87 352.61 332.75C355.85 330.63 359.02 328.42 362.01 325.97C366.75 322.08 372.14 318.98 376.25 314.37C381.66 308.41 386 301.54 391.81 295.93C395.88 292.01 398.22 286.81 401.28 282.16C401.52 283.94 401.77 285.75 402.01 287.56C404.21 284.63 406.45 281.65 409.47 279.51C413.65 276.46 418.21 273.69 421.26 269.4C424.7 264.97 424.61 259.07 426.88 254.12C428.41 250.77 430.21 247.47 432.73 244.76C434.33 245.1 435.88 245.67 437.44 246.21C438.91 243.01 440.5 239.88 442.3 236.86C444.07 237.5 445.86 238.16 447.65 238.81C446.83 248.18 448.72 257.81 445.88 266.97C444.25 271.56 439.5 274.54 438.66 279.42C440.71 282.46 444.43 284.76 444.53 288.8C445 297.44 444.41 306.11 444.73 314.77C445.01 321.91 449.27 327.91 452.1 334.23C454.76 339.64 456.88 345.72 461.83 349.52C466.02 352.75 469.13 357.07 471.65 361.67C474.05 366.15 478.04 369.46 482.12 372.35C486.25 375.48 491.8 373.99 496.59 374.27C598.5 374.3 700.4 374.16 802.31 374.29C802.41 347.36 802.32 320.44 802.35 293.51C795.98 295.45 789.29 294.52 782.81 295.48C778.94 297.24 776.41 301.01 772.59 302.9C765.29 306.72 756.67 306.26 748.72 305.49C742.24 304.86 736.5 301.68 730.81 298.8C726.49 296.53 721.51 296.88 716.8 296.87C716.04 299.29 715.29 301.73 714.57 304.18L714.481 304.191C711.209 304.577 707.861 304.973 704.63 304.22C700.25 303.36 696.7 300.35 692.4 299.28C687.24 297.98 681.86 298.12 676.66 297.05C673.03 296.371 669.569 295.06 666.132 293.758L665.82 293.64C665.33 291.42 664.82 289.22 664.33 287.02C661.97 287 659.63 286.98 657.29 286.99C658.63 290.13 660.48 293.19 660.73 296.68C655.81 295.1 651.3 292.51 646.44 290.8C646.52 291.78 646.61 292.79 646.71 293.8C644.89 293.75 643.09 293.71 641.3 293.66C640.29 292.74 639.35 291.79 638.27 291.01C635.11 291.07 632.12 292.45 628.98 292.43C627.5 291.86 626.17 291 624.82 290.23C621.46 290.87 618.1 292.02 614.65 291.71C610.9 290.54 607.8 286.83 603.56 287.87C596.77 288.5 590.69 292.57 583.86 292.68C580.7 290.47 578.7 286.71 574.91 285.44C567.3 282.74 559.11 283.03 551.18 282.32C545.4 281.5 540.69 287.72 534.88 285.54C531.17 283.61 528.74 280.04 525.78 277.2C522.93 277.68 519.92 277.93 517.47 276.12C513.96 273.5 509.54 275.16 505.58 275.05C500.53 275.29 495.66 273.75 490.89 272.32C489.75 267.03 488.27 261.4 483.42 258.28C483.38 254.12 485.32 249.43 482.72 245.7C480.73 242.36 479.05 238.73 478.74 234.81C478.14 227.74 477.97 220.5 475.6 213.73C473.78 208.27 467.51 206.34 464.85 201.48C464.48 199.56 464.59 197.61 464.58 195.69C458.44 193.67 451.91 193.59 445.7 191.89C443.86 191.46 441.95 190.88 440.07 191.36C435.4 192.46 430.44 193.53 426.75 196.8C423.68 199.5 420.14 201.71 416.1 202.56C412.1 203.8 407.7 203.34 403.83 204.97C400.4 207.06 402.28 211.47 402.12 214.69C399.17 215.72 396.29 216.99 393.21 217.56C390.58 217.84 388.03 216.92 385.5 216.41C380.29 219.98 374.57 222.79 369.72 226.87C366.76 229.2 364.08 232.07 360.51 233.46C357.7 234.22 354.77 233.64 351.94 233.45C347.5 226.94 339.38 225.1 333.31 220.6C328.63 223.12 323.65 220.95 319.13 219.24C313.86 221.35 307.87 221.69 302.45 219.95C297.675 218.277 294.163 214.497 290.81 210.887L290.59 210.65C290.534 209.135 290.486 207.628 290.439 206.139L290.43 205.86C284.18 203.46 277.93 201.1 271.56 199.08C268.42 198.15 265.8 196.15 263.32 194.1C258.58 190.22 253.32 187.01 247.79 184.38C245.38 183.38 244 181.07 242.59 179.03C243.94 178.21 245.3 177.44 246.66 176.65C244.1 173.03 241.72 168.91 237.6 166.88C232.36 164.09 225.41 164.96 221.21 160.24C218.95 158.18 217.15 154.9 213.75 154.77C208.06 153.86 202.29 154.92 196.6 154.28C192.99 152.73 190.22 149.72 186.66 148.03C183.39 146.57 182.2 142.9 179.67 140.58C178.52 139.1 176.58 137.83 176.79 135.73C176.53 132.84 177.61 129.43 175.22 127.17C171.45 122.72 168.63 117.48 167.27 111.8C166.12 107.33 166.98 102.65 166.14 98.15C163.44 95.98 159.84 95.44 157.01 93.52C155.46 92.24 154.31 90.57 153.08 89.02C154.71 85.65 156.35 82.29 158.04 78.95C156.64 78.28 155.23 77.61 153.83 76.97C150.76 77.85 147.6 77.67 144.77 76.14C145.33 72.98 146.05 69.84 147.54 66.98C145.42 62.5 143.77 57.82 141.91 53.23C140.07 48.68 135.03 46.82 132.31 42.94C129.54 39.01 126.96 34.95 123.81 31.31C119.55 26.44 122.73 18.84 118.58 13.93C114.72 13.15 111.23 15.36 108.02 17.16C102.17 20.7 95.93 23.54 89.63 26.16C89.47 22.71 89.33 19.27 89.22 15.83C85.08 14.79 80.8 15 76.69 16.07C76.59 14.35 76.48 12.64 76.39 10.93C69.43 10.66 65.38 4.37 60.86 0Z";
                    createSeaFromPath('south-waters', southWatersPath);

                    // Load ONLY main lakes (Urmia, Jazmourian)
                    const mainLakes = ['urmia', 'jazmourian'];
                    mainLakes.forEach(lakeName => {
                        const lakePath = doc.querySelector(`.lake path.${lakeName}`);
                        if (lakePath) {
                            const pathData = lakePath.getAttribute('d');
                            if (pathData) {
                                createSeaFromPath(lakeName, pathData);
                            }
                        }
                    });

                    // Center the map
                    centerMap();
                })
                .catch(err => {
                    console.error('Error loading map:', err);
                    createFallbackProvinces();
                });
        }

        function createProvinceFromPath(id, pathData, color) {
            const shape = parseSVGPath(pathData);
            if (!shape) return;

            // Extrude settings for 3D effect - smooth borders
            const extrudeSettings = {
                depth: 25,
                bevelEnabled: true,
                bevelThickness: 2,
                bevelSize: 1.5,
                bevelSegments: 2,
                curveSegments: 6
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Default dark blue gradient material (like the image)
            const defaultColor = 0x1a2844;
            const material = new THREE.MeshPhongMaterial({
                color: defaultColor,
                emissive: 0x0a1428,
                emissiveIntensity: 0.3,
                shininess: 80,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide,
                flatShading: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            

            // Add cyan glowing edges - only major borders
            const edges = new THREE.EdgesGeometry(geometry, 30);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ccff,
                transparent: true,
                opacity: 0.7,
                linewidth: 1.5
            });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            mesh.add(wireframe);

            scene.add(mesh);

            provinces.push({
                id: id,
                name: provinceNames[id] || id,
                mesh: mesh,
                color: color,
                defaultColor: defaultColor,
                originalY: 0,
                originalEmissive: 0.15,
                wireframe: wireframe
            });
        }

        function createSeaFromPath(id, pathData) {
            const shape = parseSVGPath(pathData);
            if (!shape) return;

            // Identify water body type
            const isLake = id.includes('urmia') || id.includes('jazmourian') || id === 'qom';
            
            // Same extrude as provinces but much smoother to reduce internal edges
            const extrudeSettings = {
                depth: 25,
                bevelEnabled: true,
                bevelThickness: 2,
                bevelSize: 1.5,
                bevelSegments: 2,
                curveSegments: 4
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Water material - cyan blue like the image
            const seaColor = 0x0088dd;
            const emissiveColor = 0x0066bb;
            
            const material = new THREE.MeshPhongMaterial({
                color: seaColor,
                emissive: emissiveColor,
                emissiveIntensity: 0.5,
                shininess: 300,
                transparent: true,
                opacity: 0.45,
                side: THREE.DoubleSide,
                flatShading: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.receiveShadow = true;
            mesh.castShadow = true;

            // NO wireframe for water bodies to avoid internal lines from islands
            // The material's emissive glow is enough

            scene.add(mesh);
            
            // Store water bodies separately
            waterBodies.push({
                id: id,
                mesh: mesh
            });
        }

        function parseSVGPath(pathString) {
            const shape = new THREE.Shape();
            const commands = pathString.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi);
            
            if (!commands) return null;

            let currentX = 0, currentY = 0;
            let startX = 0, startY = 0;
            const scale = 0.6; // Scale factor

            try {
                commands.forEach(cmd => {
                    const type = cmd[0].toUpperCase();
                    const coords = cmd.slice(1).trim().split(/[\s,]+/).filter(c => c).map(Number);

                    switch (type) {
                        case 'M':
                            if (coords.length >= 2) {
                                currentX = coords[0];
                                currentY = coords[1];
                                startX = currentX;
                                startY = currentY;
                                shape.moveTo(currentX * scale, -currentY * scale);
                            }
                            break;
                        case 'L':
                            for (let i = 0; i < coords.length; i += 2) {
                                if (i + 1 < coords.length) {
                                    currentX = coords[i];
                                    currentY = coords[i + 1];
                                    shape.lineTo(currentX * scale, -currentY * scale);
                                }
                            }
                            break;
                        case 'C':
                            for (let i = 0; i < coords.length; i += 6) {
                                if (i + 5 < coords.length) {
                                    shape.bezierCurveTo(
                                        coords[i] * scale, -coords[i + 1] * scale,
                                        coords[i + 2] * scale, -coords[i + 3] * scale,
                                        coords[i + 4] * scale, -coords[i + 5] * scale
                                    );
                                    currentX = coords[i + 4];
                                    currentY = coords[i + 5];
                                }
                            }
                            break;
                        case 'Z':
                            shape.lineTo(startX * scale, -startY * scale);
                            break;
                    }
                });
                return shape;
            } catch (e) {
                console.error('Error parsing path:', e);
                return null;
            }
        }

        function centerMap() {
            if (provinces.length === 0) return;

            const box = new THREE.Box3();
            provinces.forEach(p => box.expandByObject(p.mesh));
            
            const center = box.getCenter(new THREE.Vector3());
            
            // Center provinces
            provinces.forEach(p => {
                p.mesh.position.x -= center.x;
                p.mesh.position.z -= center.z;
            });
            
            // Center water bodies with the same offset
            waterBodies.forEach(w => {
                w.mesh.position.x -= center.x;
                w.mesh.position.z -= center.z;
                
                // ØªÙ†Ø¸ÛŒÙ… Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ø§Øµ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§Ù‡Ø§ÛŒ Ø¬Ù†ÙˆØ¨ÛŒ (Ø®Ù„ÛŒØ¬ ÙØ§Ø±Ø³ Ùˆ Ø¯Ø±ÛŒØ§ÛŒ Ø¹Ù…Ø§Ù†)
                if (w.id === 'south-waters') {
                    w.mesh.position.z += 345; // Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Ø¨Ù‡ Ø³Ù…Øª Ù¾Ø§ÛŒÛŒÙ† (Ø¬Ù†ÙˆØ¨)
                    w.mesh.position.x += 105; 
                }
            });
        }

        function createFallbackProvinces() {
            // Fallback: create sample provinces in a grid
            const keys = Object.keys(provinceColors);
            const gridSize = Math.ceil(Math.sqrt(keys.length));
            const spacing = 100;

            keys.forEach((key, index) => {
                const row = Math.floor(index / gridSize);
                const col = index % gridSize;
                const x = (col - gridSize / 2) * spacing;
                const z = (row - gridSize / 2) * spacing;

                createSampleProvince(key, provinceColors[key], x, z);
            });
        }

        function createSampleProvince(id, color, x, z) {
            const points = 6 + Math.floor(Math.random() * 3);
            const shape = new THREE.Shape();
            const size = 30 + Math.random() * 15;

            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const r = size * (0.8 + Math.random() * 0.4);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                
                if (i === 0) shape.moveTo(px, py);
                else shape.lineTo(px, py);
            }
            shape.closePath();

            const extrudeSettings = {
                depth: 20,
                bevelEnabled: true,
                bevelThickness: 2,
                bevelSize: 1.5,
                bevelSegments: 3
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.25,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0, z);
            mesh.rotation.x = -Math.PI / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            mesh.add(wireframe);

            scene.add(mesh);

            provinces.push({
                id: id,
                name: provinceNames[id] || id,
                mesh: mesh,
                color: color,
                originalY: 0,
                originalEmissive: 0.25,
                wireframe: wireframe
            });
        }

        function setupInteraction() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(provinces.map(p => p.mesh));

                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    const province = provinces.find(p => p.mesh === intersected);
                    
                    if (province && hoveredProvince !== province) {
                        if (hoveredProvince) resetProvince(hoveredProvince);
                        hoveredProvince = province;
                        highlightProvince(province);
                    }
                } else {
                    if (hoveredProvince) {
                        resetProvince(hoveredProvince);
                        hoveredProvince = null;
                        updateInfo(null);
                    }
                }
            });

            renderer.domElement.addEventListener('click', () => {
                if (hoveredProvince) {
                    console.log('Clicked:', hoveredProvince.name);
                }
            });
        }

        function highlightProvince(province) {
            // Lower all other provinces
            provinces.forEach(p => {
                if (p !== province && p.mesh.position.y > -10) {
                    animateValue(p.mesh.position, 'y', -15, 400, easeOutCubic);
                }
            });
            
            // Glass-like neon hover effect (like the image)
            province.mesh.material.color.setHex(province.color);
            province.mesh.material.emissive.setHex(province.color);
            province.wireframe.material.color.setHex(province.color);
            
            // Smooth extrude animation - move up
            animateValue(province.mesh.position, 'y', 50, 500, easeOutBack);
            
            // Glass-like transparent glow
            animateValue(province.mesh.material, 'emissiveIntensity', 0.8, 400);
            animateValue(province.mesh.material, 'opacity', 0.6, 400);
            animateValue(province.mesh.material, 'shininess', 250, 400);
            
            // Bright neon edges
            animateValue(province.wireframe.material, 'opacity', 1, 400);
            
            // Slight scale up
            animateValue(province.mesh.scale, 'x', 1.02, 500, easeOutBack);
            animateValue(province.mesh.scale, 'y', 1.02, 500, easeOutBack);
            animateValue(province.mesh.scale, 'z', 1.02, 500, easeOutBack);

            updateInfo(province);
        }

        function resetProvince(province) {
            // Bring all provinces back to normal level
            provinces.forEach(p => {
                if (p.mesh.position.y < 0) {
                    animateValue(p.mesh.position, 'y', 0, 400, easeOutCubic);
                }
            });
            
            // Return to default dark blue
            province.mesh.material.color.setHex(province.defaultColor);
            province.mesh.material.emissive.setHex(0x0a1428);
            province.wireframe.material.color.setHex(0x00ccff);
            
            // Smooth return animation - back to original position
            animateValue(province.mesh.position, 'y', 0, 400, easeOutCubic);
            animateValue(province.mesh.material, 'emissiveIntensity', 0.3, 400);
            animateValue(province.mesh.material, 'opacity', 0.85, 400);
            animateValue(province.mesh.material, 'shininess', 80, 400);
            animateValue(province.wireframe.material, 'opacity', 0.7, 400);
            animateValue(province.mesh.scale, 'x', 1, 400, easeOutCubic);
            animateValue(province.mesh.scale, 'y', 1, 400, easeOutCubic);
            animateValue(province.mesh.scale, 'z', 1, 400, easeOutCubic);
        }

        function updateInfo(province) {
            const nameEl = document.getElementById('province-name');
            const infoEl = document.getElementById('province-info');
            
            if (province) {
                nameEl.textContent = province.name;
                nameEl.style.color = '#' + province.color.toString(16).padStart(6, '0');
                infoEl.textContent = 'Ø§Ø³ØªØ§Ù† ' + province.name;
            } else {
                nameEl.textContent = 'Ù†Ù‚Ø´Ù‡ Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ Ø§ÛŒØ±Ø§Ù†';
                nameEl.style.color = '#00ffff';
                infoEl.textContent = 'Ù…ÙˆØ³ Ø±Ø§ Ø±ÙˆÛŒ Ø§Ø³ØªØ§Ù†â€ŒÙ‡Ø§ Ø­Ø±Ú©Øª Ø¯Ù‡ÛŒØ¯';
            }
        }

        function animateValue(obj, prop, target, duration, easingFn = easeOutCubic) {
            const start = obj[prop];
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easingFn(progress);
                
                obj[prop] = start + (target - start) * eased;
                
                if (progress < 1) requestAnimationFrame(update);
            }
            update();
        }

        // Easing functions
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function easeOutBack(t) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                controls.autoRotate = true;
            } else {
                controls.autoRotate = false;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            event.target.innerHTML = autoRotate ? 'â¸ï¸ ØªÙˆÙ‚Ù Ú†Ø±Ø®Ø´' : 'â–¶ï¸ Ø´Ø±ÙˆØ¹ Ú†Ø±Ø®Ø´';
        }

        function resetView() {
            animateValue(camera.position, 'x', 0, 1500);
            animateValue(camera.position, 'y', 500, 1500);
            animateValue(camera.position, 'z', 800, 1500);
            controls.target.set(0, 0, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleWater() {
            waterVisible = !waterVisible;
            waterBodies.forEach(w => {
                w.mesh.visible = waterVisible;
            });
        }

        function showOnlyWater() {
            // Toggle between showing only water or showing everything
            if (provincesVisible) {
                // Hide provinces, show water
                provinces.forEach(p => {
                    p.mesh.visible = false;
                });
                waterBodies.forEach(w => {
                    w.mesh.visible = true;
                });
                provincesVisible = false;
                waterVisible = true;
            } else {
                // Show everything
                provinces.forEach(p => {
                    p.mesh.visible = true;
                });
                waterBodies.forEach(w => {
                    w.mesh.visible = true;
                });
                provincesVisible = true;
                waterVisible = true;
            }
        }

        // Initialize
        window.addEventListener('load', init);
    </script>
</body>
</html>
